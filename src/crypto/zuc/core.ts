/**
 * ZUC 流密码算法 - 核心实现
 *
 * 参考标准：
 * - GM/T 0001-2012: ZUC-128 流密码算法
 * - GM/T 0001.1-2023: ZUC-256 流密码算法
 * - 官方网站：http://www.oscca.gov.cn/
 *
 * ZUC 是一个面向字的流密码算法，专为 3GPP LTE 加密和完整性保护设计。
 * 本实现基于官方标准文档。
 */

import { hexToBytes, bytesToHex } from '../../core/utils';

// F 函数使用的 S 盒
const S0: Uint8Array = new Uint8Array([
  0x3e, 0x72, 0x5b, 0x47, 0xca, 0xe0, 0x00, 0x33, 0x04, 0xd1, 0x54, 0x98, 0x09, 0xb9, 0x6d, 0xcb,
  0x7b, 0x1b, 0xf9, 0x32, 0xaf, 0x9d, 0x6a, 0xa5, 0xb8, 0x2d, 0xfc, 0x1d, 0x08, 0x53, 0x03, 0x90,
  0x4d, 0x4e, 0x84, 0x99, 0xe4, 0xce, 0xd9, 0x91, 0xdd, 0xb6, 0x85, 0x48, 0x8b, 0x29, 0x6e, 0xac,
  0xcd, 0xc1, 0xf8, 0x1e, 0x73, 0x43, 0x69, 0xc6, 0xb5, 0xbd, 0xfd, 0x39, 0x63, 0x20, 0xd4, 0x38,
  0x76, 0x7d, 0xb2, 0xa7, 0xcf, 0xed, 0x57, 0xc5, 0xf3, 0x2c, 0xbb, 0x14, 0x21, 0x06, 0x55, 0x9b,
  0xe3, 0xef, 0x5e, 0x31, 0x4f, 0x7f, 0x5a, 0xa4, 0x0d, 0x82, 0x51, 0x49, 0x5f, 0xba, 0x58, 0x1c,
  0x4a, 0x16, 0xd5, 0x17, 0xa8, 0x92, 0x24, 0x1f, 0x8c, 0xff, 0xd8, 0xae, 0x2e, 0x01, 0xd3, 0xad,
  0x3b, 0x4b, 0xda, 0x46, 0xeb, 0xc9, 0xde, 0x9a, 0x8f, 0x87, 0xd7, 0x3a, 0x80, 0x6f, 0x2f, 0xc8,
  0xb1, 0xb4, 0x37, 0xf7, 0x0a, 0x22, 0x13, 0x28, 0x7c, 0xcc, 0x3c, 0x89, 0xc7, 0xc3, 0x96, 0x56,
  0x07, 0xbf, 0x7e, 0xf0, 0x0b, 0x2b, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xa6, 0x4c, 0x10, 0xfe,
  0xbc, 0x26, 0x95, 0x88, 0x8a, 0xb0, 0xa3, 0xfb, 0xc0, 0x18, 0x94, 0xf2, 0xe1, 0xe5, 0xe9, 0x5d,
  0xd0, 0xdc, 0x11, 0x66, 0x64, 0x5c, 0xec, 0x59, 0x42, 0x75, 0x12, 0xf5, 0x74, 0x9c, 0xaa, 0x23,
  0x0e, 0x86, 0xab, 0xbe, 0x2a, 0x02, 0xe7, 0x67, 0xe6, 0x44, 0xa2, 0x6c, 0xc2, 0x93, 0x9f, 0xf1,
  0xf6, 0xfa, 0x36, 0xd2, 0x50, 0x68, 0x9e, 0x62, 0x71, 0x15, 0x3d, 0xd6, 0x40, 0xc4, 0xe2, 0x0f,
  0x8e, 0x83, 0x77, 0x6b, 0x25, 0x05, 0x3f, 0x0c, 0x30, 0xea, 0x70, 0xb7, 0xa1, 0xe8, 0xa9, 0x65,
  0x8d, 0x27, 0x1a, 0xdb, 0x81, 0xb3, 0xa0, 0xf4, 0x45, 0x7a, 0x19, 0xdf, 0xee, 0x78, 0x34, 0x60,
]);

const S1: Uint8Array = new Uint8Array([
  0x55, 0xc2, 0x63, 0x71, 0x3b, 0xc8, 0x47, 0x86, 0x9f, 0x3c, 0xda, 0x5b, 0x29, 0xaa, 0xfd, 0x77,
  0x8c, 0xc5, 0x94, 0x0c, 0xa6, 0x1a, 0x13, 0x00, 0xe3, 0xa8, 0x16, 0x72, 0x40, 0xf9, 0xf8, 0x42,
  0x44, 0x26, 0x68, 0x96, 0x81, 0xd9, 0x45, 0x3e, 0x10, 0x76, 0xc6, 0xa7, 0x8b, 0x39, 0x43, 0xe1,
  0x3a, 0xb5, 0x56, 0x2a, 0xc0, 0x6d, 0xb3, 0x05, 0x22, 0x66, 0xbf, 0xdc, 0x0b, 0xfa, 0x62, 0x48,
  0xdd, 0x20, 0x11, 0x06, 0x36, 0xc9, 0xc1, 0xcf, 0xf6, 0x27, 0x52, 0xbb, 0x69, 0xf5, 0xd4, 0x87,
  0x7f, 0x84, 0x4c, 0xd2, 0x9c, 0x57, 0xa4, 0xbc, 0x4f, 0x9a, 0xdf, 0xfe, 0xd6, 0x8d, 0x7a, 0xeb,
  0x2b, 0x53, 0xd8, 0x5c, 0xa1, 0x14, 0x17, 0xfb, 0x23, 0xd5, 0x7d, 0x30, 0x67, 0x73, 0x08, 0x09,
  0xee, 0xb7, 0x70, 0x3f, 0x61, 0xb2, 0x19, 0x8e, 0x4e, 0xe5, 0x4b, 0x93, 0x8f, 0x5d, 0xdb, 0xa9,
  0xad, 0xf1, 0xae, 0x2e, 0xcb, 0x0d, 0xfc, 0xf4, 0x2d, 0x46, 0x6e, 0x1d, 0x97, 0xe8, 0xd1, 0xe9,
  0x4d, 0x37, 0xa5, 0x75, 0x5e, 0x83, 0x9e, 0xab, 0x82, 0x9d, 0xb9, 0x1c, 0xe0, 0xcd, 0x49, 0x89,
  0x01, 0xb6, 0xbd, 0x58, 0x24, 0xa2, 0x5f, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xb8, 0x95, 0xe4,
  0xd0, 0x91, 0xc7, 0xce, 0xed, 0x0f, 0xb4, 0x6f, 0xa0, 0xcc, 0xf0, 0x02, 0x4a, 0x79, 0xc3, 0xde,
  0xa3, 0xef, 0xea, 0x51, 0xe6, 0x6b, 0x18, 0xec, 0x1b, 0x2c, 0x80, 0xf7, 0x74, 0xe7, 0xff, 0x21,
  0x5a, 0x6a, 0x54, 0x1e, 0x41, 0x31, 0x92, 0x35, 0xc4, 0x33, 0x07, 0x0a, 0xba, 0x7e, 0x0e, 0x34,
  0x88, 0xb1, 0x98, 0x7c, 0xf3, 0x3d, 0x60, 0x6c, 0x7b, 0xca, 0xd3, 0x1f, 0x32, 0x65, 0x04, 0x28,
  0x64, 0xbe, 0x85, 0x9b, 0x2f, 0x59, 0x8a, 0xd7, 0xb0, 0x25, 0xac, 0xaf, 0x12, 0x03, 0xe2, 0xf2,
]);

// ZUC-128 的线性反馈移位寄存器参数
const D_128: Uint8Array = new Uint8Array([
  22, 25, 5, 22, 25, 5, 22, 25, 5, 22, 25, 5, 22, 25, 5, 22,
]);

/**
 * ZUC 状态对象，维护 LFSR 与 FSM 的内部状态
 */
export class ZUCState {
  private lfsr: Uint32Array; // 16 个 31 位寄存器
  private r1: number; // FSM 寄存器 1
  private r2: number; // FSM 寄存器 2

  constructor() {
    this.lfsr = new Uint32Array(16);
    this.r1 = 0;
    this.r2 = 0;
  }

  /**
   * 使用密钥与 IV 初始化状态
   * @param key - 128 位密钥（16 字节）
   * @param iv - 128 位初始向量（16 字节）
   */
  initialize(key: Uint8Array, iv: Uint8Array): void {
    if (key.length !== 16) {
      throw new Error('Key must be 16 bytes for ZUC-128');
    }
    if (iv.length !== 16) {
      throw new Error('IV must be 16 bytes for ZUC-128');
    }

    // 按照标准将密钥与 IV 写入 LFSR
    for (let i = 0; i < 16; i++) {
      this.lfsr[i] = ((key[i] << 23) | (D_128[i] << 8) | iv[i]) >>> 0;
      this.lfsr[i] &= 0x7FFFFFFF; // 仅保留 31 位
    }

    // 初始化 FSM 寄存器
    this.r1 = 0;
    this.r2 = 0;

    // 执行 32 轮初始化过程（不产生输出）
    for (let i = 0; i < 32; i++) {
      const w = this.bitReorganization();
      const f = this.fFunction(w);
      this.lfsrWithInitMode(f >>> 1);
    }
  }

  /**
   * 比特重组：从 LFSR 中抽取特定位构成 32 位字
   * 优化：预分配数组重复使用
   */
  private x: Uint32Array = new Uint32Array(4);

  private bitReorganization(): Uint32Array {
    this.x[0] = (((this.lfsr[15] & 0x7FFF8000) << 1) | (this.lfsr[14] & 0xFFFF)) >>> 0;
    this.x[1] = (((this.lfsr[11] & 0xFFFF) << 16) | (this.lfsr[9] >>> 15)) >>> 0;
    this.x[2] = (((this.lfsr[7] & 0xFFFF) << 16) | (this.lfsr[5] >>> 15)) >>> 0;
    this.x[3] = (((this.lfsr[2] & 0xFFFF) << 16) | (this.lfsr[0] >>> 15)) >>> 0;
    return this.x;
  }

  /**
   * F 函数：使用双 S 盒的非线性变换
   * 优化：统一使用 >>> 0 保持 32 位无符号运算
   */
  private fFunction(x: Uint32Array): number {
    const w = ((x[0] ^ this.r1) + this.r2) >>> 0;
    const w1 = (this.r1 + x[1]) >>> 0;
    const w2 = (this.r2 ^ x[2]) >>> 0;

    const u = this.l1(((w1 << 16) | (w2 >>> 16)) >>> 0);
    const v = this.l2(((w2 << 16) | (w1 >>> 16)) >>> 0);

    // 更新 FSM 寄存器
    this.r1 = this.s(this.l1(((v << 16) | (u >>> 16)) >>> 0));
    this.r2 = this.s(this.l2(((u << 16) | (v >>> 16)) >>> 0));

    return (w ^ x[3]) >>> 0;
  }

  /**
   * S 盒代换
   */
  private s(x: number): number {
    return (
      (S0[(x >>> 24) & 0xFF] << 24) |
      (S1[(x >>> 16) & 0xFF] << 16) |
      (S0[(x >>> 8) & 0xFF] << 8) |
      (S1[x & 0xFF])
    ) >>> 0;
  }

  /**
   * 线性变换 L1
   */
  private l1(x: number): number {
    return (x ^ this.rotl(x, 2) ^ this.rotl(x, 10) ^ this.rotl(x, 18) ^ this.rotl(x, 24)) >>> 0;
  }

  /**
   * 线性变换 L2
   */
  private l2(x: number): number {
    return (x ^ this.rotl(x, 8) ^ this.rotl(x, 14) ^ this.rotl(x, 22) ^ this.rotl(x, 30)) >>> 0;
  }

  /**
   * 循环左移
   */
  private rotl(x: number, n: number): number {
    return ((x << n) | (x >>> (32 - n))) >>> 0;
  }

  /**
   * 初始化模式下的 LFSR（带反馈值 u）
   */
  private lfsrWithInitMode(u: number): void {
    const s16 = this.addMod(
      this.addMod(
        this.addMod(this.mulByPow2(this.lfsr[0], 8), this.lfsr[4]),
        this.mulByPow2(this.lfsr[10], 8)
      ),
      this.lfsr[13]
    );

    // 左移 LFSR
    for (let i = 0; i < 15; i++) {
      this.lfsr[i] = this.lfsr[i + 1];
    }

    this.lfsr[15] = this.addMod(s16, u) & 0x7FFFFFFF;
  }

  /**
   * 工作模式下的 LFSR（无附加反馈）
   */
  private lfsrWithWorkMode(): void {
    const s16 = this.addMod(
      this.addMod(
        this.addMod(this.mulByPow2(this.lfsr[0], 8), this.lfsr[4]),
        this.mulByPow2(this.lfsr[10], 8)
      ),
      this.lfsr[13]
    );

    // 左移 LFSR
    for (let i = 0; i < 15; i++) {
      this.lfsr[i] = this.lfsr[i + 1];
    }

    this.lfsr[15] = s16 & 0x7FFFFFFF;
  }

  /**
   * Addition modulo 2^31 - 1
   */
  private addMod(a: number, b: number): number {
    const c = (a + b) >>> 0;
    return ((c & 0x7FFFFFFF) + (c >>> 31)) >>> 0;
  }

  /**
   * Multiplication by 2^k modulo 2^31 - 1
   */
  private mulByPow2(x: number, k: number): number {
    return (((x << k) | (x >>> (31 - k))) & 0x7FFFFFFF) >>> 0;
  }

  /**
   * Generate one 32-bit keystream word
   */
  generateKeyword(): number {
    const x = this.bitReorganization();
    const z = this.fFunction(x);
    this.lfsrWithWorkMode();
    return z >>> 0;
  }
}

/**
 * 生成 ZUC-128 密钥流
 * @param key - 128 位密钥（16 字节或 32 个十六进制字符）
 * @param iv - 128 位初始向量（16 字节或 32 个十六进制字符）
 * @param length - 需要输出的 32 位密钥字数量
 * @returns 32 位密钥字数组
 */
export function generateKeystream(
  key: string | Uint8Array,
  iv: string | Uint8Array,
  length: number
): Uint32Array {
  const keyBytes = typeof key === 'string' ? hexToBytes(key) : key;
  const ivBytes = typeof iv === 'string' ? hexToBytes(iv) : iv;

  const state = new ZUCState();
  state.initialize(keyBytes, ivBytes);

  const keystream = new Uint32Array(length);
  for (let i = 0; i < length; i++) {
    keystream[i] = state.generateKeyword();
  }

  return keystream;
}

/**
 * 使用 ZUC-128 加密或解密数据（流密码中加解密相同）
 * 优化：利用按字处理减少内存分配
 * @param key - 128 位密钥（16 字节或 32 个十六进制字符）
 * @param iv - 128 位初始向量（16 字节或 32 个十六进制字符）
 * @param data - 待加密或解密的数据
 * @returns 十六进制字符串形式的密文或明文
 */
export function process(
  key: string | Uint8Array,
  iv: string | Uint8Array,
  data: string | Uint8Array
): string {
  const keyBytes = typeof key === 'string' ? hexToBytes(key) : key;
  const ivBytes = typeof iv === 'string' ? hexToBytes(iv) : iv;
  const dataBytes = typeof data === 'string' ? new TextEncoder().encode(data) : data;

  const state = new ZUCState();
  state.initialize(keyBytes, ivBytes);

  // 生成密钥流并与数据异或
  // 优化：按 4 字节批量处理
  const output = new Uint8Array(dataBytes.length);
  const numFullWords = Math.floor(dataBytes.length / 4);
  const remainder = dataBytes.length % 4;

  // 处理完整的 32 位字
  for (let i = 0; i < numFullWords; i++) {
    const keyword = state.generateKeyword();
    const offset = i * 4;

    // XOR 4 bytes at once
    output[offset] = dataBytes[offset] ^ ((keyword >>> 24) & 0xFF);
    output[offset + 1] = dataBytes[offset + 1] ^ ((keyword >>> 16) & 0xFF);
    output[offset + 2] = dataBytes[offset + 2] ^ ((keyword >>> 8) & 0xFF);
    output[offset + 3] = dataBytes[offset + 3] ^ (keyword & 0xFF);
  }

  // 处理剩余字节
  if (remainder > 0) {
    const keyword = state.generateKeyword();
    const offset = numFullWords * 4;

    for (let i = 0; i < remainder; i++) {
      const keyByte = (keyword >>> (24 - i * 8)) & 0xFF;
      output[offset + i] = dataBytes[offset + i] ^ keyByte;
    }
  }

  return bytesToHex(output);
}
