/**
 * ZUC Stream Cipher Algorithm - Core Implementation
 *
 * ZUC is a word-oriented stream cipher designed for 3GPP LTE encryption and integrity protection.
 * Based on GM/T 0001-2012 (ZUC-128) and GM/T 0001.1-2023 (ZUC-256)
 *
 * @see http://www.oscca.gov.cn/sca/xxgk/2012-03/21/content_1002389.shtml
 */

import { hexToBytes, bytesToHex } from '../../core/utils';

// S-boxes for the F function
const S0: Uint8Array = new Uint8Array([
  0x3e, 0x72, 0x5b, 0x47, 0xca, 0xe0, 0x00, 0x33, 0x04, 0xd1, 0x54, 0x98, 0x09, 0xb9, 0x6d, 0xcb,
  0x7b, 0x1b, 0xf9, 0x32, 0xaf, 0x9d, 0x6a, 0xa5, 0xb8, 0x2d, 0xfc, 0x1d, 0x08, 0x53, 0x03, 0x90,
  0x4d, 0x4e, 0x84, 0x99, 0xe4, 0xce, 0xd9, 0x91, 0xdd, 0xb6, 0x85, 0x48, 0x8b, 0x29, 0x6e, 0xac,
  0xcd, 0xc1, 0xf8, 0x1e, 0x73, 0x43, 0x69, 0xc6, 0xb5, 0xbd, 0xfd, 0x39, 0x63, 0x20, 0xd4, 0x38,
  0x76, 0x7d, 0xb2, 0xa7, 0xcf, 0xed, 0x57, 0xc5, 0xf3, 0x2c, 0xbb, 0x14, 0x21, 0x06, 0x55, 0x9b,
  0xe3, 0xef, 0x5e, 0x31, 0x4f, 0x7f, 0x5a, 0xa4, 0x0d, 0x82, 0x51, 0x49, 0x5f, 0xba, 0x58, 0x1c,
  0x4a, 0x16, 0xd5, 0x17, 0xa8, 0x92, 0x24, 0x1f, 0x8c, 0xff, 0xd8, 0xae, 0x2e, 0x01, 0xd3, 0xad,
  0x3b, 0x4b, 0xda, 0x46, 0xeb, 0xc9, 0xde, 0x9a, 0x8f, 0x87, 0xd7, 0x3a, 0x80, 0x6f, 0x2f, 0xc8,
  0xb1, 0xb4, 0x37, 0xf7, 0x0a, 0x22, 0x13, 0x28, 0x7c, 0xcc, 0x3c, 0x89, 0xc7, 0xc3, 0x96, 0x56,
  0x07, 0xbf, 0x7e, 0xf0, 0x0b, 0x2b, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xa6, 0x4c, 0x10, 0xfe,
  0xbc, 0x26, 0x95, 0x88, 0x8a, 0xb0, 0xa3, 0xfb, 0xc0, 0x18, 0x94, 0xf2, 0xe1, 0xe5, 0xe9, 0x5d,
  0xd0, 0xdc, 0x11, 0x66, 0x64, 0x5c, 0xec, 0x59, 0x42, 0x75, 0x12, 0xf5, 0x74, 0x9c, 0xaa, 0x23,
  0x0e, 0x86, 0xab, 0xbe, 0x2a, 0x02, 0xe7, 0x67, 0xe6, 0x44, 0xa2, 0x6c, 0xc2, 0x93, 0x9f, 0xf1,
  0xf6, 0xfa, 0x36, 0xd2, 0x50, 0x68, 0x9e, 0x62, 0x71, 0x15, 0x3d, 0xd6, 0x40, 0xc4, 0xe2, 0x0f,
  0x8e, 0x83, 0x77, 0x6b, 0x25, 0x05, 0x3f, 0x0c, 0x30, 0xea, 0x70, 0xb7, 0xa1, 0xe8, 0xa9, 0x65,
  0x8d, 0x27, 0x1a, 0xdb, 0x81, 0xb3, 0xa0, 0xf4, 0x45, 0x7a, 0x19, 0xdf, 0xee, 0x78, 0x34, 0x60,
]);

const S1: Uint8Array = new Uint8Array([
  0x55, 0xc2, 0x63, 0x71, 0x3b, 0xc8, 0x47, 0x86, 0x9f, 0x3c, 0xda, 0x5b, 0x29, 0xaa, 0xfd, 0x77,
  0x8c, 0xc5, 0x94, 0x0c, 0xa6, 0x1a, 0x13, 0x00, 0xe3, 0xa8, 0x16, 0x72, 0x40, 0xf9, 0xf8, 0x42,
  0x44, 0x26, 0x68, 0x96, 0x81, 0xd9, 0x45, 0x3e, 0x10, 0x76, 0xc6, 0xa7, 0x8b, 0x39, 0x43, 0xe1,
  0x3a, 0xb5, 0x56, 0x2a, 0xc0, 0x6d, 0xb3, 0x05, 0x22, 0x66, 0xbf, 0xdc, 0x0b, 0xfa, 0x62, 0x48,
  0xdd, 0x20, 0x11, 0x06, 0x36, 0xc9, 0xc1, 0xcf, 0xf6, 0x27, 0x52, 0xbb, 0x69, 0xf5, 0xd4, 0x87,
  0x7f, 0x84, 0x4c, 0xd2, 0x9c, 0x57, 0xa4, 0xbc, 0x4f, 0x9a, 0xdf, 0xfe, 0xd6, 0x8d, 0x7a, 0xeb,
  0x2b, 0x53, 0xd8, 0x5c, 0xa1, 0x14, 0x17, 0xfb, 0x23, 0xd5, 0x7d, 0x30, 0x67, 0x73, 0x08, 0x09,
  0xee, 0xb7, 0x70, 0x3f, 0x61, 0xb2, 0x19, 0x8e, 0x4e, 0xe5, 0x4b, 0x93, 0x8f, 0x5d, 0xdb, 0xa9,
  0xad, 0xf1, 0xae, 0x2e, 0xcb, 0x0d, 0xfc, 0xf4, 0x2d, 0x46, 0x6e, 0x1d, 0x97, 0xe8, 0xd1, 0xe9,
  0x4d, 0x37, 0xa5, 0x75, 0x5e, 0x83, 0x9e, 0xab, 0x82, 0x9d, 0xb9, 0x1c, 0xe0, 0xcd, 0x49, 0x89,
  0x01, 0xb6, 0xbd, 0x58, 0x24, 0xa2, 0x5f, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xb8, 0x95, 0xe4,
  0xd0, 0x91, 0xc7, 0xce, 0xed, 0x0f, 0xb4, 0x6f, 0xa0, 0xcc, 0xf0, 0x02, 0x4a, 0x79, 0xc3, 0xde,
  0xa3, 0xef, 0xea, 0x51, 0xe6, 0x6b, 0x18, 0xec, 0x1b, 0x2c, 0x80, 0xf7, 0x74, 0xe7, 0xff, 0x21,
  0x5a, 0x6a, 0x54, 0x1e, 0x41, 0x31, 0x92, 0x35, 0xc4, 0x33, 0x07, 0x0a, 0xba, 0x7e, 0x0e, 0x34,
  0x88, 0xb1, 0x98, 0x7c, 0xf3, 0x3d, 0x60, 0x6c, 0x7b, 0xca, 0xd3, 0x1f, 0x32, 0x65, 0x04, 0x28,
  0x64, 0xbe, 0x85, 0x9b, 0x2f, 0x59, 0x8a, 0xd7, 0xb0, 0x25, 0xac, 0xaf, 0x12, 0x03, 0xe2, 0xf2,
]);

// LFSR parameters for ZUC-128
const D_128: Uint8Array = new Uint8Array([
  22, 25, 5, 22, 25, 5, 22, 25, 5, 22, 25, 5, 22, 25, 5, 22,
]);

/**
 * ZUC State - manages LFSR and FSM states
 */
export class ZUCState {
  private lfsr: Uint32Array; // 16 31-bit words
  private r1: number; // FSM register 1
  private r2: number; // FSM register 2

  constructor() {
    this.lfsr = new Uint32Array(16);
    this.r1 = 0;
    this.r2 = 0;
  }

  /**
   * Initialize ZUC state with key and IV
   * @param key 128-bit key (16 bytes)
   * @param iv 128-bit IV (16 bytes)
   */
  initialize(key: Uint8Array, iv: Uint8Array): void {
    if (key.length !== 16) {
      throw new Error('Key must be 16 bytes for ZUC-128');
    }
    if (iv.length !== 16) {
      throw new Error('IV must be 16 bytes for ZUC-128');
    }

    // Load key and IV into LFSR according to the specification
    for (let i = 0; i < 16; i++) {
      this.lfsr[i] = ((key[i] << 23) | (D_128[i] << 8) | iv[i]) >>> 0;
      this.lfsr[i] &= 0x7FFFFFFF; // Keep 31 bits
    }

    // Initialize FSM registers
    this.r1 = 0;
    this.r2 = 0;

    // Run initialization stage (32 times without producing output)
    for (let i = 0; i < 32; i++) {
      const w = this.bitReorganization();
      const f = this.fFunction(w);
      this.lfsrWithInitMode(f >>> 1);
    }
  }

  /**
   * Bit Reorganization - extract specific bits from LFSR to form words
   */
  private bitReorganization(): Uint32Array {
    const x = new Uint32Array(4);
    x[0] = ((this.lfsr[15] & 0x7FFF8000) << 1) | (this.lfsr[14] & 0xFFFF);
    x[1] = ((this.lfsr[11] & 0xFFFF) << 16) | (this.lfsr[9] >>> 15);
    x[2] = ((this.lfsr[7] & 0xFFFF) << 16) | (this.lfsr[5] >>> 15);
    x[3] = ((this.lfsr[2] & 0xFFFF) << 16) | (this.lfsr[0] >>> 15);
    return x;
  }

  /**
   * F Function - nonlinear function with two S-boxes
   */
  private fFunction(x: Uint32Array): number {
    const w = (x[0] ^ this.r1) + this.r2;
    const w1 = this.r1 + x[1];
    const w2 = this.r2 ^ x[2];

    const u = this.l1((w1 << 16) | (w2 >>> 16));
    const v = this.l2((w2 << 16) | (w1 >>> 16));

    // Update registers
    this.r1 = this.s((this.l1((v << 16) | (u >>> 16))) >>> 0);
    this.r2 = this.s((this.l2((u << 16) | (v >>> 16))) >>> 0);

    return (w ^ x[3]) >>> 0;
  }

  /**
   * S-box substitution
   */
  private s(x: number): number {
    return (
      (S0[(x >>> 24) & 0xFF] << 24) |
      (S1[(x >>> 16) & 0xFF] << 16) |
      (S0[(x >>> 8) & 0xFF] << 8) |
      (S1[x & 0xFF])
    ) >>> 0;
  }

  /**
   * Linear transformation L1
   */
  private l1(x: number): number {
    return (x ^ this.rotl(x, 2) ^ this.rotl(x, 10) ^ this.rotl(x, 18) ^ this.rotl(x, 24)) >>> 0;
  }

  /**
   * Linear transformation L2
   */
  private l2(x: number): number {
    return (x ^ this.rotl(x, 8) ^ this.rotl(x, 14) ^ this.rotl(x, 22) ^ this.rotl(x, 30)) >>> 0;
  }

  /**
   * Rotate left
   */
  private rotl(x: number, n: number): number {
    return ((x << n) | (x >>> (32 - n))) >>> 0;
  }

  /**
   * LFSR with initialization mode (feedback with u)
   */
  private lfsrWithInitMode(u: number): void {
    const s16 = this.addMod(
      this.addMod(
        this.addMod(this.mulByPow2(this.lfsr[0], 8), this.lfsr[4]),
        this.mulByPow2(this.lfsr[10], 8)
      ),
      this.lfsr[13]
    );

    // Shift LFSR
    for (let i = 0; i < 15; i++) {
      this.lfsr[i] = this.lfsr[i + 1];
    }

    this.lfsr[15] = this.addMod(s16, u) & 0x7FFFFFFF;
  }

  /**
   * LFSR with working mode (no feedback)
   */
  private lfsrWithWorkMode(): void {
    const s16 = this.addMod(
      this.addMod(
        this.addMod(this.mulByPow2(this.lfsr[0], 8), this.lfsr[4]),
        this.mulByPow2(this.lfsr[10], 8)
      ),
      this.lfsr[13]
    );

    // Shift LFSR
    for (let i = 0; i < 15; i++) {
      this.lfsr[i] = this.lfsr[i + 1];
    }

    this.lfsr[15] = s16 & 0x7FFFFFFF;
  }

  /**
   * Addition modulo 2^31 - 1
   */
  private addMod(a: number, b: number): number {
    const c = (a + b) >>> 0;
    return ((c & 0x7FFFFFFF) + (c >>> 31)) >>> 0;
  }

  /**
   * Multiplication by 2^k modulo 2^31 - 1
   */
  private mulByPow2(x: number, k: number): number {
    return (((x << k) | (x >>> (31 - k))) & 0x7FFFFFFF) >>> 0;
  }

  /**
   * Generate one 32-bit keystream word
   */
  generateKeyword(): number {
    const x = this.bitReorganization();
    const z = this.fFunction(x);
    this.lfsrWithWorkMode();
    return z >>> 0;
  }
}

/**
 * Generate keystream using ZUC-128
 * @param key 128-bit key (16 bytes or 32 hex chars)
 * @param iv 128-bit IV (16 bytes or 32 hex chars)
 * @param length Number of keystream words to generate
 * @returns Array of 32-bit keystream words
 */
export function generateKeystream(
  key: string | Uint8Array,
  iv: string | Uint8Array,
  length: number
): Uint32Array {
  const keyBytes = typeof key === 'string' ? hexToBytes(key) : key;
  const ivBytes = typeof iv === 'string' ? hexToBytes(iv) : iv;

  const state = new ZUCState();
  state.initialize(keyBytes, ivBytes);

  const keystream = new Uint32Array(length);
  for (let i = 0; i < length; i++) {
    keystream[i] = state.generateKeyword();
  }

  return keystream;
}

/**
 * Encrypt/decrypt data using ZUC-128 (stream cipher, so encryption = decryption)
 * @param key 128-bit key (16 bytes or 32 hex chars)
 * @param iv 128-bit IV (16 bytes or 32 hex chars)
 * @param data Data to encrypt/decrypt
 * @returns Encrypted/decrypted data as hex string
 */
export function process(
  key: string | Uint8Array,
  iv: string | Uint8Array,
  data: string | Uint8Array
): string {
  const keyBytes = typeof key === 'string' ? hexToBytes(key) : key;
  const ivBytes = typeof iv === 'string' ? hexToBytes(iv) : iv;
  const dataBytes = typeof data === 'string' ? new TextEncoder().encode(data) : data;

  const state = new ZUCState();
  state.initialize(keyBytes, ivBytes);

  // Generate keystream and XOR with data
  const output = new Uint8Array(dataBytes.length);
  let offset = 0;

  while (offset < dataBytes.length) {
    const keyword = state.generateKeyword();

    // Extract 4 bytes from the keyword
    for (let i = 0; i < 4 && offset < dataBytes.length; i++) {
      const keyByte = (keyword >>> (24 - i * 8)) & 0xFF;
      output[offset] = dataBytes[offset] ^ keyByte;
      offset++;
    }
  }

  return bytesToHex(output);
}
